# LoLLMS Client - Developer Documentation

Welcome to the developer documentation for `lollms_client`! This guide is intended for developers who want to understand the project's architecture, contribute new features, fix bugs, or create new bindings.

**Project Links:**
*   **GitHub Repository:** [https://github.com/ParisNeo/simplified_lollms](https://github.com/ParisNeo/simplified_lollms) (Note: The client is part of this larger ecosystem, this doc focuses on the `lollms_client` library itself)
*   **PyPI Package:** [https://pypi.org/project/lollms-client/](https://pypi.org/project/lollms-client/)
*   **License:** Apache 2.0

## Table of Contents

1.  [Introduction](#1-introduction)
    *   [Project Goal](#project-goal)
    *   [Key Features](#key-features)
2.  [Getting Started for Developers](#2-getting-started-for-developers)
3.  [Project Structure](#3-project-structure)
4.  [Core Concepts & Architecture](#4-core-concepts--architecture)
    *   [`LollmsClient` (The Orchestrator)](#lollmsclient-the-orchestrator)
    *   [Bindings (The Backends)](#bindings-the-backends)
        *   [Abstract Base Classes (ABCs)](#abstract-base-classes-abcs)
        *   [Binding Managers](#binding-managers)
    *   [Supported Modalities and Bindings](#supported-modalities-and-bindings)
        *   [LLM (Large Language Model) Bindings](#llm-large-language-model-bindings)
        *   [TTS (Text-to-Speech) Bindings](#tts-text-to-speech-bindings)
        *   [TTI (Text-to-Image) Bindings](#tti-text-to-image-bindings)
        *   [STT (Speech-to-Text) Bindings](#stt-speech-to-text-bindings)
        *   [TTM (Text-to-Music/Sound) Bindings](#ttm-text-to-musicsound-bindings)
        *   [TTV (Text-to-Video) Bindings](#ttv-text-to-video-bindings)
        *   [MCP (Model Context Protocol) Bindings](#mcp-model-context-protocol-bindings)
    *   [High-Level Operations (in `LollmsClient`)](#high-level-operations-in-lollmsclient)
    *   [`LollmsDiscussion` & `LollmsMessage`](#lollmsdiscussion--lollmsmessage)
    *   [Configuration (`lollms_config.py`)](#configuration-lollms_configpy)
    *   [Utilities & Types](#utilities--types)
5.  [Adding New Bindings (A Practical Guide)](#5-adding-new-bindings-a-practical-guide)
    *   [General Steps for Modality Bindings](#general-steps-for-modality-bindings)
    *   [Adding New MCP Bindings](#adding-new-mcp-bindings)
    *   [Adding New Local MCP Tools](#adding-new-local-mcp-tools)
6.  [Running Examples & Tests](#6-running-examples--tests)
7.  [Coding Standards & Conventions](#7-coding-standards--conventions)
8.  [Contribution Guidelines](#8-contribution-guidelines)
9.  [Reporting Issues](#9-reporting-issues)
10. [Roadmap & Future Ideas](#10-roadmap--future-ideas)
11. [Community & Contact](#11-community--contact)

---

## 1. Introduction

### Project Goal

`lollms_client` is a Python client library designed to provide a unified and easy-to-use interface for interacting with various AI model backends and services. It aims to abstract the complexities of different APIs and local model execution, allowing developers to seamlessly switch between different AI modalities (LLM, TTS, TTI, STT, TTM, TTV), and enable powerful function calling via the Model Context Protocol (MCP).

The "LoLLMS" ecosystem (Lord of Large Language and Multimodal Systems) aims to be a versatile platform for AI interaction, and this client is a key component for Python-based applications and integrations.

### Key Features

*   **Modular Binding System:** Easily add support for new AI backends or libraries.
*   **Multi-Modality:** Supports Large Language Models (LLM), Text-to-Speech (TTS), Text-to-Image (TTI), Speech-to-Text (STT), Text-to-Music/Sound (TTM), and Text-to-Video (TTV).
*   **Function Calling (MCP):** Integrated Model Context Protocol support, including a `local_mcp` binding for executing local Python tools with default utilities.
*   **Unified API:** Provides a consistent `LollmsClient` interface for common operations across different bindings.
*   **Local & Remote Backends:** Supports both local model execution and remote services.
*   **Helper Utilities:** Includes tools for discussion management and various AI-driven tasks directly on the `LollmsClient`.
*   **Dependency Management:** Uses `pipmaster` within bindings to attempt to ensure necessary Python packages are installed.

## 2. Getting Started for Developers
(Content remains largely the same: Prerequisites, Cloning, Virtual Env, Editable Install, Dev Dependencies)

## 3. Project Structure

Here's an overview of the `lollms_client` directory structure:

```
ğŸ“ lollms_client/
â”œâ”€ ğŸ“ ai_documentation/         # Markdown files generated by AI documentation tools
â”œâ”€ ğŸ“ dist/                     # Build artifacts
â”œâ”€ ğŸ“ examples/                 # Example scripts demonstrating client usage
â”‚  â”œâ”€ ğŸ“ article_summary/
â”‚  â”œâ”€ ğŸ“ deep_analyze/
â”‚  â”œâ”€ ğŸ“ function_calling_with_local_custom_mcp.py # Shows custom MCP tools
â”‚  â”œâ”€ ğŸ“ local_mcp.py                              # Shows default MCP tools
â”‚  â”œâ”€ ğŸ“ generate_and_speak/
â”‚  â””â”€ ... (other examples)
â”œâ”€ ğŸ“ lollms_client/            # The core library source code
â”‚  â”œâ”€ ğŸ“ llm_bindings/           # LLM-specific binding implementations
â”‚  â”‚  â””â”€ ...
â”‚  â”œâ”€ ğŸ“ tts_bindings/           # Text-to-Speech binding implementations
â”‚  â”‚  â””â”€ ...
â”‚  â”œâ”€ ğŸ“ tti_bindings/           # Text-to-Image binding implementations
â”‚  â”‚  â””â”€ ...
â”‚  â”œâ”€ ğŸ“ stt_bindings/           # Speech-to-Text binding implementations
â”‚  â”‚  â””â”€ ...
â”‚  â”œâ”€ ğŸ“ ttm_bindings/           # Text-to-Music/Sound binding implementations
â”‚  â”‚  â””â”€ ...
â”‚  â”œâ”€ ğŸ“ ttv_bindings/           # Text-to-Video binding implementations
â”‚  â”‚  â””â”€ ...
â”‚  â”œâ”€ ğŸ“ mcp_bindings/           # Model Context Protocol binding implementations
â”‚  â”‚  â””â”€ ğŸ“ local_mcp/          # Example: Local MCP tool executor
â”‚  â”‚     â”œâ”€ ğŸ“ default_tools/    # Packaged tools for local_mcp
â”‚  â”‚     â”‚  â”œâ”€ ğŸ“ file_writer/
â”‚  â”‚     â”‚  â”œâ”€ ğŸ“ generate_image_from_prompt/
â”‚  â”‚     â”‚  â”œâ”€ ğŸ“ internet_search/
â”‚  â”‚     â”‚  â””â”€ ğŸ“ python_interpreter/
â”‚  â”‚     â””â”€ ğŸ“„ __init__.py
â”‚  â”œâ”€ ğŸ“„ __init__.py             # Makes lollms_client a package, exports key classes
â”‚  â”œâ”€ ğŸ“„ lollms_config.py        # Configuration classes
â”‚  â”œâ”€ ğŸ“„ lollms_core.py          # LollmsClient class, main orchestrator (includes generate_with_mcp, summarize, etc.)
â”‚  â”œâ”€ ğŸ“„ lollms_discussion.py    # LollmsDiscussion and LollmsMessage classes
â”‚  â”œâ”€ ğŸ“„ lollms_llm_binding.py   # ABC for LLM bindings and LollmsLLMBindingManager
â”‚  â”œâ”€ ğŸ“„ lollms_tts_binding.py   # ABC for TTS bindings and LollmsTTSBindingManager
â”‚  â”œâ”€ ğŸ“„ lollms_tti_binding.py   # ABC for TTI bindings and LollmsTTIBindingManager
â”‚  â”œâ”€ ğŸ“„ lollms_stt_binding.py   # ABC for STT bindings and LollmsSTTBindingManager
â”‚  â”œâ”€ ğŸ“„ lollms_ttm_binding.py   # ABC for TTM bindings and LollmsTTMBindingManager
â”‚  â”œâ”€ ğŸ“„ lollms_ttv_binding.py   # ABC for TTV bindings and LollmsTTVBindingManager
â”‚  â”œâ”€ ğŸ“„ lollms_mcp_binding.py   # ABC for MCP bindings and LollmsMCPBindingManager
â”‚  â”œâ”€ ğŸ“„ lollms_types.py         # Enums (MSG_TYPE, ELF_COMPLETION_FORMAT, etc.)
â”‚  â””â”€ ğŸ“„ lollms_utilities.py     # Helper functions
â”œâ”€ ğŸ“ lollms_client.egg-info/   # Packaging metadata
â”œâ”€ ğŸ“„ CHANGELOG.md
â”œâ”€ ğŸ“„ DOC_DEV.md                # This developer documentation file
â”œâ”€ ğŸ“„ DOC_USE.md                # User-focused documentation
â”œâ”€ ğŸ“„ pyproject.toml
â”œâ”€ ğŸ“„ README.md
â””â”€ ğŸ“„ requirements.txt
```

## 4. Core Concepts & Architecture

### `LollmsClient` (The Orchestrator)

Located in `lollms_client/lollms_core.py`, the `LollmsClient` class is the main entry point. Its responsibilities include:
*   Initializing and managing different types of bindings (LLM, TTS, TTI, STT, TTM, TTV, MCP).
*   Providing a unified API for common operations like text generation (`generate_text`), speech synthesis (`tts.generate_audio`), and **function calling** (`generate_with_mcp`).
*   Orchestrating interactions involving MCP tools by leveraging an active MCP binding.
*   Offering direct methods for high-level tasks like `sequential_summarize`, `deep_analyze`, `generate_code`, `yes_no`, etc.
*   Storing default generation parameters.

### Bindings (The Backends)
(General description of Bindings, ABCs, and Binding Managers remains the same)

### Supported Modalities and Bindings
(LLM, TTS, TTI, STT, TTM, TTV sections remain largely the same)

#### MCP (Model Context Protocol) Bindings
*   **Directory:** `lollms_client/mcp_bindings/`
*   **ABC:** `LollmsMCPBinding` (in `lollms_mcp_binding.py`)
*   **Manager:** `LollmsMCPBindingManager` (in `lollms_mcp_binding.py`)
*   **Implemented Bindings (Examples):**
    *   `local_mcp`: Discovers and executes local Python tools. Each tool is defined by a `<tool_name>.py` file (with an `execute` function) and a `<tool_name>.mcp.json` file (describing the tool's name, description, input/output schemas).
        *   **Default Tools for `local_mcp`**:
            *   `file_writer`: Writes or appends text to files.
            *   `internet_search`: Performs web searches using DuckDuckGo.
            *   `python_interpreter`: Executes Python code snippets in a restricted environment.
            *   `generate_image_from_prompt`: Generates an image by calling the `LollmsClient`'s active TTI binding.

### High-Level Operations (in `LollmsClient`)

The `LollmsClient` class itself now includes several high-level methods for common AI tasks, previously housed in `TasksLibrary`. These methods often combine multiple calls to the LLM binding or other utilities. Examples:
*   `sequential_summarize`, `deep_analyze`: For processing and understanding long texts.
*   `generate_code`, `generate_codes`: For structured code generation.
*   `yes_no`, `multichoice_question`, `multichoice_ranking`: For specific Q&A formats.
*   `extract_code_blocks`, `extract_thinking_blocks`, `remove_thinking_blocks`: Text processing utilities.

These methods leverage the active LLM binding for their core AI operations.

### `LollmsDiscussion` & `LollmsMessage`
(Content remains the same)

### Configuration (`lollms_config.py`)
(Content remains the same)

### Utilities & Types
(Content remains the same, though `lollms_functions.py` and `lollms_tasks.py` are gone)

## 5. Adding New Bindings (A Practical Guide)

### General Steps for Modality Bindings (LLM, TTS, TTI, STT, TTM, TTV)
(General steps for adding modality bindings remain the same: Create dir, `__init__.py`, `BindingName`, implement ABC, handle deps, add test block)

### Adding New MCP Bindings

Contributing a new MCP binding (e.g., to interact with a remote MCP tool server) follows a similar pattern:

1.  **Create Binding Directory:** `lollms_client/mcp_bindings/<your_mcp_binding_name>/`
2.  **Create `__init__.py`:** Inside the new directory.
3.  **Define `BindingName`:** At the top of your `__init__.py`.
    ```python
    # lollms_client/mcp_bindings/my_remote_mcp/__init__.py
    BindingName = "MyRemoteMCPBinding" # Must match your class name
    ```
4.  **Implement the `LollmsMCPBinding` Class:**
    ```python
    from lollms_client.lollms_mcp_binding import LollmsMCPBinding
    from typing import List, Dict, Any
    # Import any SDKs or libraries needed to talk to your remote MCP server

    BindingName = "MyRemoteMCPBinding"

    class MyRemoteMCPBinding(LollmsMCPBinding):
        def __init__(self, tool_server_url: str, api_key: str = None, **kwargs):
            super().__init__(binding_name="my_remote_mcp")
            self.tool_server_url = tool_server_url
            self.api_key = api_key
            # Initialize your client for the remote server
            # self.remote_client = MyRemoteSDK(base_url=tool_server_url, api_key=api_key)

        def discover_tools(self, **kwargs) -> List[Dict[str, Any]]:
            # Implement logic to fetch tool definitions from self.tool_server_url
            # try:
            #     response = self.remote_client.get_tools_list()
            #     return response.json().get("tools", [])
            # except Exception as e:
            #     # Log error
            #     return []
            return [{"name": "remote_tool_example", "description": "Example tool from remote server", "input_schema":{}}] # Placeholder

        def execute_tool(self, tool_name: str, params: Dict[str, Any], **kwargs) -> Dict[str, Any]]:
            # Implement logic to call the specific tool on self.tool_server_url
            # try:
            #     response = self.remote_client.execute(tool_name, params)
            #     return response.json().get("result", {"error": "No result field"})
            # except Exception as e:
            #     # Log error
            #     return {"error": f"Failed to execute remote tool {tool_name}: {e}"}
            return {"output": f"Executed {tool_name} remotely with {params}. Placeholder.", "status_code": 200} # Placeholder
    ```
    You *must* implement `discover_tools` and `execute_tool`.
5.  **Handle Dependencies:** Use `pipmaster.ensure_packages()` if your binding requires specific Python packages for communication.
6.  **Add a Test Block:** Include an `if __name__ == "__main__":` block for standalone testing.

### Adding New Local MCP Tools (for `local_mcp` binding)

If you want to add a new tool to be used by the existing `local_mcp` binding:
1.  **Choose/Create a Tools Folder:** This can be any folder. You'll pass its path to `LollmsClient` via `mcp_binding_config={"tools_folder_path": "your/tools/dir"}`.
    *   The `local_mcp` binding also has a `default_tools` subdirectory packaged with it. You can add tools there if modifying the library directly, but using a custom external folder is cleaner for user-defined tools.
2.  **Create Tool Subdirectory:** Inside your chosen tools folder, create a subdirectory for your new tool, e.g., `my_custom_tool/`.
3.  **Create `<tool_name>.mcp.json`:** In the tool's subdirectory (e.g., `my_custom_tool/my_custom_tool.mcp.json`), define the tool's metadata.
    ```json
    {
        "name": "my_custom_tool",
        "description": "A brief description of what my custom tool does.",
        "input_schema": {
            "type": "object",
            "properties": {
                "param1": {"type": "string", "description": "Description of param1"},
                "param2": {"type": "integer", "default": 10}
            },
            "required": ["param1"]
        },
        "output_schema": { /* Define expected output structure */ }
    }
    ```
4.  **Create `<tool_name>.py`:** In the tool's subdirectory (e.g., `my_custom_tool/my_custom_tool.py`), implement the tool's logic.
    ```python
    from typing import Dict, Any

    def execute(params: Dict[str, Any], lollms_client_instance: Any = None) -> Dict[str, Any]:
        # params will contain {'param1': 'value', 'param2': value_or_default}
        # lollms_client_instance is the LollmsClient that invoked this,
        # useful if your tool needs to call TTI, TTS, or even another LLM call.
        
        param1_value = params.get("param1")
        param2_value = params.get("param2", 10) # Use default if not provided

        # Your tool's logic here
        result_data = f"Tool processed {param1_value} and {param2_value}"
        
        # Return a dictionary (which will be nested under "output" by local_mcp)
        return {"processed_data": result_data, "status_message": "Custom tool executed successfully."}
    ```
    The `execute` function must accept `params: Dict[str, Any]` and can optionally accept `lollms_client_instance: Any`. It should return a dictionary.

The `local_mcp` binding will automatically discover and make this tool available to the LLM when `generate_with_mcp` is called.

## 6. Running Examples & Tests
(Content updated to reflect MCP examples and removal of TasksLibrary examples)
*   **Examples:** The `examples/` directory contains various scripts.
    *   `examples/function_calling_with_local_custom_mcp.py`: Demonstrates `generate_with_mcp` using custom local tools.
    *   `examples/local_mcp.py`: Demonstrates `generate_with_mcp` using the default tools packaged with the `local_mcp` binding.
    *   Other examples show text generation, multimodal features, etc.
*   **Binding Self-Tests:** Most binding `__init__.py` files have an `if __name__ == "__main__":` block. Run these directly to test that specific binding.
*   **Adding Formal Tests:** Contributions of unit/integration tests are welcome.

## 7. Coding Standards & Conventions
(Content remains the same)

## 8. Contribution Guidelines
(Content remains the same)

## 9. Reporting Issues
(Content remains the same)

## 10. Roadmap & Future Ideas
(Content updated to remove TasksLibrary ideas and potentially add MCP-related ones)
*   **More Bindings:** LLM, TTS, TTI, STT, TTM, TTV, and **MCP** bindings.
*   **Enhanced High-Level Ops:** Add more sophisticated pre-built operations directly to `LollmsClient`.
*   **Asynchronous Operations:** Explore `async/await`.
*   **Improved Error Handling.**
*   **Standardized Configuration.**
*   **Comprehensive Testing Framework.**
*   **Plugin System for Bindings.**
*   **Documentation Generation.**
*   **More Default Tools for `local_mcp`**: Consider adding more generally useful local tools.
*   **Support for Remote MCP Tool Servers**: Beyond `local_mcp`, bindings for standardized remote MCP endpoints.

## 11. Community & Contact
(Content remains the same)

Thank you for your interest in contributing to `lollms_client`!